h1. Conversation

Allows you to have stateful conversations with your users over SMS, email or whatever service you like. For example you could use conversation to accept multistep commands from users over SMS to perform some task.

h2. Usage

Conversation is best described using an "example":http://github.com/dwilkie/drinking about drinking so if your new to Conversation head over there and take a look. If you want to know more about configuring Conversation keep reading...

h2. Creation

conversation = Conversation.create(:with => "someone", :topic => "something"). This will create and return a new instance Conversation with the state: "new", with: "someone" and topic: "something"

The returned value will be an instance of the superclass Conversation. conversation.details gives you the instance as a SomethingConversation provided that SomethingConversation is defined and subclasses Conversation.

If SomethingConversation is not defined or does not subclass conversation conversation.details will try and return an instance of the unknown_topic_subclass which can be set via Conversation.unknown_topic_subclass = MyUnknownConversation

If the unknown topic subclass has not been defined then calling conversation.details will return nil

Similarly you can create Conversations with no topic conversation = Conversation.create(:with => "someone"). In this case calling conversation.details will return an instance of the blank_topic_subclass which can be set via Conversation.blank_topic_subclass = MyBlankConversation or nil if it has not been defined

h2. Finding

h3. Default

Conversation.with("someone") will return all conversations that are not "finished" with "someone" in the last 24 hours. If a conversation has the state: "finished" or is older than 24 hours it will not be returned.

h3. Overriding Defaults

Conversation.converser("someone") will return all conversations with "someone" regardless of state or time.

Conversation.in_progress will return all conversations that are not "finished"

Conversation.recent will return all conversations in the last 24 hours

Conversation.with("someone") is just a shortcut for Conversation.converser("someone").in_progress.recent

Just like with create the returned conversations will be an instances of the superclass Conversation. Use conversation.details on each member to get the specific type of Conversation

Conversation.find_or_create_with("someone", "something") will either return an instance of the most recent conversation with "someone" that is not "finished" and is within the last 24hrs as a SomethingConversation.

If no conversation is found it will create and return a new instance of SomethingConversation following the same rules as for conversation.details. Here, however if there is not unknown topic subclass defined or no blank topic subclass defined and SomethingConversation is not defined, then an error will be raised.

h2. Configuration

Configuration can be done in the conversation initializer in the config/initializers directory.

h3. Configure Conversation to use Mail

In the conversation initializer uncomment the following code:
<pre>
Conversation.converse do |with, notice|
  Mail.deliver do
    to with
    from "someone@example.com"
    subject notice
    body notice
  end
end
</pre>

Conversation will now use the Mail to send notifications
Note: You will also need to set up the "Mail":http://github.com/mikel/mail gem

h3. Define finishing keywords

Conversation.finishing_keywords = ["stop", "cancel", "end", "whatever"]
Now when you call super("cancel") in your move_along! method in your Conversation subclass it will change the conversations state to "finished"

h3. Define an unknown topic subclass

Conversation.unknown_topic_subclass = UnknownTopicConversation
Now when you call Conversation.find_or_create_with("someone", "something") and SomethingConversation has not been defined you'll get an instance of UnknownTopicConversation instead of an error

h3. Define a blank topic subclass

Conversation.blank_topic_subclass = BlankTopicConversation
Now when you call Conversation.find_or_create_with("someone") you'll get an instance of BlankTopicConversation instead of an error

h3. Define exclusion classes

Conversation.exclude AbstractConversation
Conversation.exclude "abstract_conversation"
Conversation.exclude /abstract/
Conversation.exclude :abstract_conversation
Conversation.exclude [InternalConversation, /abstract/]

Any of these will ignore AbstractConversation when finding Conversations
So if you have a class defined as AbstractConversation < Conversation when you call Conversation.find_or_create_with("someone", "abstract") you'll either get an error or an instance of unknown_topic_conversation if it is defined. Also calling Conversation.new(:topic => "abstract", :with => "someone").details will return an instance of unknown_topic_conversation if defined or nil

This can be useful if you are defining conversations that you never want to work with directly.

h2. Installation

Add the following to your Gemfile
gem "conversation"

h2. Setup

rails g conversation:skeleton
This will generate a migration file for your conversation class and an initializer under config/initializers/conversation.rb

h2. Notes

Conversation is no longer compatible with Rails 2.3.x
To use with Rails 2.3.x you must install version 0.1.0

Copyright (c) 2010 David Wilkie, released under the MIT license
